---
title: "Organize SNAPP Results"
output: html_document 
---

This script reads in the SNAPP results and prepares covariates for analysis. 

```{r setup}
rm(list = ls())
require( tidyverse)

responses <- read_csv('../raw_data/snapp_responses-toAndy.csv')  # largest list of responses 

responses %>% 
  group_by( user_id, filename, created_at, answer ) %>% 
  mutate( n_duplicate_rows = n() ) %>% 
  arrange( desc(n_duplicate_rows), user_id, filename) %>% 
  filter( n_duplicate_rows > 1 ) %>% 
  write_csv('~/Desktop/duplicate_snapp_responses_to_check.csv') 


user_info <- read_csv('../raw_data/snapp_users_noemail.csv')     # list of user information 
taxa_info <- read_csv('../raw_data/species incl mivs for Andy out.csv')  # list of taxonomic information for taxa in photos and taxa not in photos 
responses_2  <- read_csv('../raw_data/snapp_responses_out-corr-only100spp-toErol.csv') # includes photo region information 
responses_3  <- read_csv('../raw_data/DT.sm100.csv')   # includes user region information 

# !!! Some repeats of the exact same user, time, filename and answer!!!! 
responses %>% 
  group_by( user_id, `user_time(ms)`, answer, created_at, filename, score ) %>% 
  mutate( n = n() )  %>% 
  arrange(desc(n)) 

```

# remove duplicates 
```{r }
responses <- 
  responses %>% 
  distinct()  # keep distinct only 


responses %>% 
  group_by( user_id, `user_time(ms)`, answer, created_at, filename, score ) %>% 
  mutate( n = n() )  %>% 
  arrange(desc(n))

```

# show duplicate records 
```{r  }
# same user_id, filename, user_time,  answer, and score 
# !!! Many duplicates, no timestamp so impossible to tell if these are true duplicates or repeat questions

responses_2 %>%  
  group_by( user_id, filename, user_time_sec, species, answer ) %>% 
  mutate( n = n()  ) %>% 
  arrange( desc( n)) %>% 
  select( user_id, filename, user_time_sec, species, answer, n )

```


# show duplicate records 
```{r  }

# !!! Many records have the exact same user_id, filename, timestamp, user_time,  answer, and score 
responses_3 %>% 
  group_by( user_id, user_region, filename, created_at, user_time, answer, score ) %>% 
  mutate( n = n()  ) %>% 
  arrange( desc( n)) %>% 
  select( user_id, user_region, filename, created_at, user_time, answer, score, n, seq, sppseq, X1)

```

## remove duplicates 
```{r }
responses_3 <-
  responses_3 %>% 
  select( - X1, -sppseq, -seq )  %>%  # Drop X1 and sequence info
  distinct() 

responses_3 %>% # note that fewer records are included 
  group_by( user_id, user_region, filename, created_at, user_time, answer, score) %>% 
  mutate( n = n()  ) %>% 
  arrange( desc( n)) %>% 
  select( user_id, user_region, filename, created_at, user_time, answer, score, n)

```

## Rename some columns 
```{r}

responses <- 
  responses %>% 
  rename( 'response' = answer , 'id' = user_id)

responses_3 <- 
  responses_3 %>% 
  select( user_id, filename, species, created_at) %>% 
  rename( 'id' = user_id, 'photo_key' = species ) %>% 
  mutate( datetime = strftime( created_at, format = '%Y-%m-%d %H:%M:%S', tz = 'UTC'))

responses_2 <- 
  responses_2 %>%
  rename( 'photo_key' = species, 
          'photo_region' = global_region )  # photo region information 

user_info <- 
  user_info %>% 
  rename( 'user_region' = region ) 

```
## Make definitive list of photos by filename and information for each  
## "filename" = distinct photo identifier 
## "photo_key" = correct taxa for each photo 
## "photo_region" = photo origin 

```{r}

u_filename <- unique(c(responses$filename, responses_2$filename, responses_3$filename)) # all unique filenames 

# all distinct filename, species ID combinations 
# some filenames do not have species information 

photo_key <-
  responses_3 %>% 
  distinct(filename, photo_key) %>%
  bind_rows(
    (responses_2 %>% distinct(filename, photo_key))
    ) %>% 
  distinct() %>% 
  arrange(filename )

photo_key <- 
  tibble( filename = u_filename ) %>%
  left_join( photo_key, by = 'filename' ) %>% 
  distinct() %>% 
  left_join( responses_2 %>% distinct( filename, photo_region), by = 'filename')  #  Add photo region 

```

## Make definitive list of all snake taxa 
## Taxa can be species binomial, genus, or family 
## Taxa have unique MIVS status: "y", "n","ambiguous" ( *ambiguous for higher taxonomic levels that contain both MIVS and non-MIVS )
## Taxa "inCSchallenge": TRUE or FALSE

```{r}
u_binom <- unique( taxa_info$binomial)  
u_genus <- unique( taxa_info$genus )
u_key <- unique( photo_key$photo_key )

u_key [ u_key %in% c(u_binom, u_genus) ] %>% sort() # show all taxa in photos 

```

# check taxa not in key
```{r }

u_key [!u_key %in% c(u_binom, u_genus) ] %>% sort() # any key taxa missing from the taxa table 

``` 

# Set up definitive taxa table 
```{r}
binomial_info <- taxa_info %>% select(binomial, genus, family) %>% distinct()
genus_info    <- taxa_info %>% select( genus, family) %>% distinct()
family_info   <- taxa_info %>% select( family ) %>% distinct()

all_taxa_info <- 
  taxa_info %>% 
  select(family, genus, binomial, mivs, inCSchallenge ) %>% 
  gather(taxonomic_level, taxa, c(family, genus, binomial)) %>% 
  select( taxa, taxonomic_level, inCSchallenge, mivs ) %>% 
  group_by( taxa, taxonomic_level) %>% 
  mutate(   mivs = ifelse( taxonomic_level != 'binomial' & n_distinct(mivs) > 1, 'ambiguous', mivs),  # classify mivs at higher taxonomic levels (more than one species)
            inCSchallenge = ifelse ( any( inCSchallenge == 1), 1, 0)) %>% 
  distinct() 

# Make tables with binomial, genus and family level information. 
# Binomial has genus, family and MIVs status 
# Genus has family and MIVS status 
# Family has only MIVS status 

binomial_info <- 
  binomial_info %>% 
  left_join( all_taxa_info, by = c('binomial' = 'taxa' )) %>% 
  rename( taxa = binomial ) 
  
genus_info <- 
  genus_info %>% 
  left_join( all_taxa_info, by = c('genus' = 'taxa'))  %>% 
  mutate( taxa = genus ) 

family_info <- 
  family_info %>% 
  left_join( all_taxa_info, by = c('family' = 'taxa')) %>% 
  mutate( taxa = family, genus = NA) 

all_taxa_info <- 
  bind_rows( binomial_info, genus_info, family_info)

```


# Add family, genus and mivs for each photo key
```{r}
key_info <- 
  photo_key %>% 
  left_join(all_taxa_info, by = c('photo_key' = 'taxa')) %>% 
  rename( 'key_genus' = genus, 
          'key_family' = family, 
          'key_mivs' = mivs, 
          'key_taxonomic_level' = taxonomic_level )  %>% 
  distinct()

```


# Add family, genus and mivs for all possible responses 
```{r}
response_info <- 
  all_taxa_info %>% 
  select( - inCSchallenge ) %>% 
  rename( 'response' = taxa, 
          'response_genus' = genus, 
          'response_family' = family, 
          'response_taxonomic_level' = taxonomic_level, 
          'response_mivs' = mivs )  %>% 
  distinct()

```


## Format user info 

```{r}
user_info <-
  user_info %>% 
  mutate( user_region = str_to_title( str_replace(user_region, '-', ' ' )) ) %>% 
  mutate( user_region = ifelse( user_region == 'Australasia Oceania' , 'Australasia/Oceania', user_region)) %>% # format to match taxa region
  distinct() 

all_ids <- unique( c(user_info$id, responses$id, responses_2$user_id, responses_3$id ))

user_info <- 
  tibble( id = all_ids )  %>% 
  left_join(user_info, by = 'id' ) %>% 
  distinct()

user_info
```

## Format responses 
### Include user ID, filename, datetime, response, photo_key
## "taxa_repeat" column gives the number of previous photos of the same taxa 
```{r}
responses <- 
  responses %>% 
  mutate( datetime = paste0( created_at , ':00' )) %>% 
  separate( datetime, c('date', 'time'), sep = ' ') %>%  
  mutate( date = lubridate::mdy( date )) %>% 
  mutate( datetime2 = paste0( date, time )) %>% 
  mutate( datetime2 = strftime( datetime2, format = '%m/%d/%Y %H:%M:%S', tz = 'UTC' )) %>% 
  select( -date, -time, -score, -created_at) %>% 
  distinct()

# Calculate taxa repeats per user 
# order filenames per user based on the timestamp in datetime2
responses <- 
  responses %>% 
  left_join(key_info, by = 'filename') %>% 
  group_by(id, photo_key)  %>% 
  arrange( id, datetime2 ) %>% 
  mutate( taxa_repeat = row_number()) %>% 
  mutate( taxa_repeat = ifelse( is.na(photo_key), NA, taxa_repeat)) %>% 
  distinct()

responses %>% group_by( id, filename, datetime2 ) %>% mutate( n = n() ) %>% arrange( desc(n)) %>% view

responses %>% filter( id == "b9c4207d-ccf3-42b5-b6ef-203559869d05", filename == '1083.jpg') 
responses_2 %>% filter( user_id == "b9c4207d-ccf3-42b5-b6ef-203559869d05", filename == '1083.jpg') 
responses_3 %>% filter( id == "b9c4207d-ccf3-42b5-b6ef-203559869d05", filename == '1083.jpg') 

responses_2$filename

```

## merge user info and response info 
## Calculate "home_region" field when user region is provided 
```{r}
response_data <- 
  responses %>% 
  ungroup() %>% 
  mutate( unique_question = row_number() ) %>% 
  left_join( user_info, by = 'id') %>% 
  left_join( response_info, by = 'response' )  %>% 
  mutate( inCSchallenge = ifelse( is.na(inCSchallenge), 0, inCSchallenge)) %>% 
  mutate( skip = is.na(response)) %>% 
  mutate( home_region = user_region == photo_region ) %>%             
  mutate( home_region = ifelse( is.na(photo_region) | is.na(user_region), NA, home_region)) %>% 
  select( unique_question, id, user_region, datetime2, filename, photo_region, home_region, photo_key, inCSchallenge, taxa_repeat, starts_with('key'), skip, starts_with('response')) %>% 
  distinct()

``` 


## Calculate user scores: 
## Match user responses to photo key 
## Score user response:  Correct species == 3, correct genus = 2, correct family = 1, incorrect or skip = 0 

```{r }

response_data <- 
  response_data %>% 
  mutate( correct_binomial = (response == photo_key), 
          correct_genus = (response_genus == key_genus), 
          correct_family = (response_family == key_family) ) %>%
  mutate( correct_binomial = ifelse( is.na(correct_binomial), F, correct_binomial),  
          correct_genus = ifelse( is.na(correct_genus), F, correct_genus), 
          correct_family = ifelse( is.na(correct_family), F, correct_family)) %>% 
  rowwise() %>% 
  mutate( score = (correct_binomial + correct_genus + correct_family) ) %>%  # CALCULATE SCORE 
  mutate( score = ifelse( is.na(photo_key), NA, score ))  %>%                # Score is NA where no key_taxa are provided
  distinct() 




#  left_join( responses_3 %>% distinct(id, filename, datetime), by = c('id', 'filename'))


response_data %>% group_by( id, filename,  datetime2, filename, response, score ) %>% mutate( n = n()) %>% arrange( desc(n))

photo_order %>% 
  group_by( id, filename , datetime ) %>% mutate( n = n() ) %>% filter( n > 1)

responses %>% nrow()
response_data %>% nrow()

```
